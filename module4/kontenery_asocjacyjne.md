# Kontenery asocjacyjne

___

## Posortowane

* Set
* Multiset
* Map
* Multimap
  
___

## NieuporzÄ…dkowane

* Unordered_set
* Unordered_multiset
* Unordered_map
* Unordered_multimap

___

## Quiz

Do czego moÅ¼esz uÅ¼yÄ‡:

* Set?
* Multiset?
* Map?
* Multimap?
* Unordered_set?
* Unordered_multiset?
* Unordered_map?
* Unordered_multimap?

___

## Notacja duÅ¼ego O

<img src="https://miro.medium.com/max/1180/1*QGb8BP4vq0KB4Ee0-p2VuA.png">

___

## Cechy `std::map<K, T>` i `std::multimap<K, T>` #1

* Forma drzewa binarnego (red-black-tree)
* Nie jest cache friendly
* Pozwala przechowywaÄ‡ parÄ™ klucz-wartoÅ›Ä‡ (key-value)
* Multimapa moÅ¼e mieÄ‡ wiele takich samych kluczy
* Mapa ma unikatowe klucze
* AlternatywÄ… dla multimapy jest `std::map<key, std::vector<value>>`

___

## Cechy `std::map<K, T>` i `std::multimap<K, T>` #2

PoniewaÅ¼ jest ona zaimplementowana przewaÅ¼nie jako red-black-tree (GNU standard C++ library) to czas wstawiania, usuwania i dodawania elementu to `O(log(n)`).

Zalety:

* Szybkie wyszukiwanie elementÃ³w (kontenery sekwencyjnie `O(n)`),
* WzglÄ™dnie szybki czas ich dodawania i usuwania np. `std::vector<T>` dodaje elementy w Å›rodku w czasie `O(n)` ale `std::list<T>` (jeÅ¼eli mamy podany iterator) w czasie `O(1)`. StÄ…d mapa jest wzglÄ™dnie szybka zarÃ³wno w dodawaniu jak i usuwaniu.
* Idealna, gdy czÄ™sto poszukujemy danych a rzadziej je dodajemy lub usuwamy.

JeÅ¼eli bÄ™dziemy jej uÅ¼ywaÄ‡ jako zwykÅ‚ego kontenera, to stracimy na wydajnoÅ›ci. MapÄ™ naleÅ¼y sortowaÄ‡ wtedy, kiedy faktycznie chcemy posiadaÄ‡ pary klucz-wartoÅ›Ä‡ i czÄ™sto je wyszukiwaÄ‡. W innym przypadku moÅ¼emy uÅ¼yÄ‡ `std::vector<pair<K, V>>` lub innego kontenera.
  
___

## Operacje na `std::map<K, T>` i `std::multimap<K, T>`

* dodawanie elementu: insert(), emplace(), emplace_hint(). Dodatkowo mapa posiada: insert_or_assign(), try_emplace() oraz operator[] (dodajÄ…co modyfikujÄ…cy)
* modyfikowanie/dostÄ™p do elementu: at(), operator[] (Multimapa nie posiada takich opcji)
* pierwszy/ostatni element: Brak
* rozmiar/czy kontener jest pusty: size(), empty()
* wyczyszczenie nieuÅ¼ywanej pamiÄ™ci: Brak
* iterator poczÄ…tku/koÅ„ca: begin(), end()
* odwrÃ³cony (ang. reverse) iterator: rbegin(), rend()
* staÅ‚y iterator: cbegin(), cend(), crbegin(), crend()
* wyczyszczenie kontenera: clear()
* przygotowanie elementu do usuniÄ™cia: Brak
* wymazanie elementÃ³w z pamiÄ™ci: erase()
* podmiana caÅ‚ego kontenera: swap()
* zliczenie elementÃ³w pasujÄ…cych do danego klucza: count (dla mapy to 0 albo 1, dla multimapy od 0 do n)
* odnalezienie elementu o podanym kluczu: find()

___

## PrzykÅ‚ad uÅ¼ycia `emplace_hint`

```cpp
int main() {
    std::map<int, std::string> map;

    auto it = map.begin();
    map.emplace_hint(it, 10, "Ten");

    std::cout << map[10] << '\n';
}
```

Output:
`Ten`

Podpowiadamy mapie miejsce, gdzie powinna wstawiÄ‡ element, dziÄ™ki temu taka operacja bÄ™dzie miaÅ‚a zÅ‚oÅ¼onoÅ›Ä‡ O(1). JeÅ¼eli jednak Åºle podpowiemy, to czas wstawienia bÄ™dzie O(long(n)). Raczej rzadko stosowane ğŸ™‚

___

### PrzykÅ‚ad uÅ¼ycia `insert_or_assign`

```C++
int main() {
    std::map<int, std::string> map;

    auto it = map.begin();
    map.insert_or_assign(it, 10, "Ten");
    std::cout << map[10] << '\n';
    map.insert_or_assign(it, 10, "Dziesiec");
    std::cout << map[10] << '\n';
    map[10] = "Cent";
    std::cout << map[10] << '\n';
}
```

Otput:

```C++
Ten
Dziesiec
Cent
```

___

### PrzykÅ‚ad uÅ¼ycia `count`

```C++
int main() {
    std::multimap<int, std::string> map;

    map.insert({5, "Five"});
    map.insert({5, "Funf"});
    map.insert({5, "Piec"});
    map.insert({5, "Cinq"});
    std::cout << map.count(5) << '\n';
}
```

Output: `4`

___

### PrzykÅ‚ad uÅ¼ycia `find`

```C++
int main() {
    std::multimap<int, std::string> map;

    map.insert({5, "Five"});
    map.insert({5, "Funf"});
    map.insert({5, "Piec"});
    map.insert({5, "Cinq"});
    auto it = map.find(5);

    for (; it != map.end() ; ++it) {
        std::cout << it->first << " | " << it->second << '\n';
    }
}
```

Output:

```C++
5 | Five
5 | Funf
5 | Piec
5 | Cinq
```

___

## Zadanie 1

* StwÃ³rz multimapÄ™ i wypeÅ‚nij jÄ… podanymi wartoÅ›ciami

```C++
map.insert({5, "Ala"});
map.insert({5, "Ma"});
map.insert({5, "Kota"});
map.insert({5, "A"});
map.insert({5, "Kot"});
map.insert({5, "Ma"});
map.insert({5, "Ale"});
```

* Napisz funkcjÄ™, ktÃ³ra wyÅ›wietli sÅ‚owa w mapie o liczbie znakÃ³w rÃ³wnej 3.

___

## RozwiÄ…zanie

```C++
std::vector<std::pair<int, std::string>> result;
std::copy_if(it, end(map), std::back_inserter(result),
                [](const auto& pair) { return pair.second.size() == 3; });
std::for_each(begin(result), end(result),
            [](const auto& pair) { std::cout << pair.second << '\n'; });
```

___

## Cechy `std::set<T>` i `std::multiset<T>` #1

* Forma drzewa binarnego (red-black-tree)
* Nie jest cache friendly
* Pozwala przechowywaÄ‡ wartoÅ›ci w uporzÄ…dkowanej kolejnoÅ›ci
* Multiset moÅ¼e mieÄ‡ wiele takich samych wartoÅ›ci
* Set ma unikatowe wartoÅ›ci
* AlternatywÄ… dla multiset jest posortowany `std::vector<T>`

___

## Cechy `std::set<T>` i `std::multiset<T>` #2

PoniewaÅ¼ jest on zaimplementowany przewaÅ¼nie jako red-black-tree (GNU standard C++ library) to czas wstawiania, usuwania i dodawania elementu to `O(log(n)`).

Zalety:

* Szybkie wyszukiwanie elementÃ³w (kontenery sekwencyjnie `O(n)`),
* WzglÄ™dnie szybki czas ich dodawania i usuwania np. `std::vector<T>` dodaje elementy w Å›rodku w czasie `O(n)` ale `std::list<T>` (jeÅ¼eli mamy podany iterator) w czasie `O(1)`. StÄ…d set jest wzglÄ™dnie szybki zarÃ³wno w dodawaniu jak i usuwaniu.
* Idealny, gdy chcemy zawsze posiadaÄ‡ posortowane wartoÅ›ci.

JeÅ¼eli nie zaleÅ¼y nam, aby kontener byÅ‚ zawsze posortowany, lecz jedynie w specyficznych momentach, to moÅ¼e lepiej nam uÅ¼yÄ‡ `std::vector<T>` i sortowaÄ‡ go, gdy przyjdzie taka potrzeba. JeÅ¼eli teÅ¼ zaleÅ¼y nam tylko czasami na unikatowych wartoÅ›ciach, to moÅ¼emy wtedy uÅ¼yÄ‡ `std::unique<>`.
  
___

## Operacje na `std::set<T>` i `std::multiset<T>`

* dodawanie elementu: insert(), emplace(), emplace_hint()
* modyfikowanie/dostÄ™p do elementu: Brak
* pierwszy/ostatni element: Brak
* rozmiar/czy kontener jest pusty: size(), empty()
* wyczyszczenie nieuÅ¼ywanej pamiÄ™ci: Brak
* iterator poczÄ…tku/koÅ„ca: begin(), end()
* odwrÃ³cony (ang. reverse) iterator: rbegin(), rend()
* staÅ‚y iterator: cbegin(), cend(), crbegin(), crend()
* wyczyszczenie kontenera: clear()
* przygotowanie elementu do usuniÄ™cia: Brak
* wymazanie elementÃ³w z pamiÄ™ci: erase()
* podmiana caÅ‚ego kontenera: swap()
* zliczenie elementÃ³w pasujÄ…cych do danego klucza: count (dla set to 0 albo 1, dla multiset od 0 do n)
* odnalezienie elementu o podanym kluczu: find()

___

## PrzykÅ‚ad uÅ¼ycia `std::set<T>`

```C++
std::set<int> set {5, 4, 3, 2, 1, 0, 6, 8, 7};
for (const auto el : set) {
    std::cout << el << ' ';
}
std::cout << '\n';

std::set<int, std::greater<int>> set2 {5, 4, 3, 2, 1, 0, 6, 8, 7};
for (const auto el : set2) {
    std::cout << el << ' ';
}
std::cout << '\n';
```

Output:

```C++
0 1 2 3 4 5 6 7 8
8 7 6 5 4 3 2 1 0
```

___

## PrzykÅ‚ad uÅ¼ycia `std::multiset<T>`

```C++
    std::multiset<int> set {5, 4, 3, 2, 1, 0, 6, 8, 7, 1, 2, 3, 4, 5, 6};
    for (const auto el : set) {
        std::cout << el << ' ';
    }
    std::cout << '\n';

    std::multiset<int, std::greater<int>> set2 {5, 4, 3, 2, 1, 0, 6, 8, 7, 1, 2, 3, 4, 5, 6};
    for (const auto el : set2) {
        std::cout << el << ' ';
    }
    std::cout << '\n';
```

Output:

```C++
0 1 1 2 2 3 3 4 4 5 5 6 6 7 8
8 7 6 6 5 5 4 4 3 3 2 2 1 1 0
```

___

## Hash Table

<image src="https://ycpcs.github.io/cs201-fall2018/notes/figures/chainedHashing.png">

___

## Funkcja mieszajÄ…ca

Jest to funkcja, ktÃ³ra z dowolnego obiektu wygeneruje nam index w tablicy. NajwaÅ¼niejszÄ… jej cechÄ… jest to, Å¼e zawsze dla takich samych danych wejÅ›ciowych musi wygenerowaÄ‡ ten sam index. KolejnÄ… waÅ¼nÄ… cechÄ… jest takie generowanie indexu, aby tylko dla jednej kombinacji mÃ³gÅ‚ on siÄ™ powtÃ³rzyÄ‡ np.:

```C++
size_t hash(const std::string& str) { return str.size(); }
```

```C++
size_t hash(const std::string& str) {
    size_t index = 0;
    for (size_t i = 0 ; i < str.size() ; ++i) {
        index += (int)str[i];
    }
    return index;
}
```

```C++
size_t hash(const std::string& str) {
    size_t index = 0;
    for (size_t i = 0 ; i < str.size() - 1 ; ++i) {
        index += ((int)str[i] * int(str[i + 1]) * (i + 5)) & (((int)str[i] + int(str[i + 1]) * i * i));
    }
    return index * str.size();
}
```

OceÅ„ funkcje mieszajÄ…ce.
___

## Cechy `std::unordered_set<T>` i `std::unordered_multiset<T>` #1

* Forma tablicy hash.
* MoÅ¼e, ale nie musi byÄ‡ cache friendly. Hash table, czÄ™sto sÄ… tworzone w formie hybrydy `std::vector<T>` i `std::list<T>`.
* WartoÅ›ci nie sÄ… posortowane
* Multiset moÅ¼e mieÄ‡ wiele takich samych wartoÅ›ci
* Set ma unikatowe wartoÅ›ci

___

## Cechy `std::unordered_set<T>` i `std::unordered_multiset<T>` #2

PoniewaÅ¼ jest on zaimplementowany jako hash table to Å›redni czas dodawania, usuwania, dostÄ™pu oraz modyfikacji to `O(1)`. Najgorszy dla wszystkich operacji czas to `O(n)`.

Zalety:

* BÅ‚yskawiczne wyszukiwanie elementÃ³w
* BÅ‚yskawicznie szybki czas ich dodawania i usuwania
* OczywiÅ›cie przy zaÅ‚oÅ¼eniu, Å¼e mamy dobrÄ… funkcjÄ™ mieszajÄ…cÄ….

DoskonaÅ‚y dla kontenerÃ³w read-only. Czas odczytu `O(1)`.
DoskonaÅ‚y dla kontenerÃ³w majÄ…cych dobrÄ… funkcjÄ™ mieszajÄ…cÄ…. Czas dodawania, dostepu i modyfikacji `O(1)`.
  
___

## Operacje na `std::unordered_set<T>` i `std::unordered_multiset<T>`

* dodawanie elementu: insert(), emplace(), emplace_hint()
* modyfikowanie/dostÄ™p do elementu: Brak
* pierwszy/ostatni element: Brak
* rozmiar/czy kontener jest pusty: size(), empty()
* wyczyszczenie nieuÅ¼ywanej pamiÄ™ci: Brak
* iterator poczÄ…tku/koÅ„ca: begin(), end()
* odwrÃ³cony (ang. reverse) iterator: BRAK
* staÅ‚y iterator: cbegin(), cend()
* wyczyszczenie kontenera: clear()
* przygotowanie elementu do usuniÄ™cia: Brak
* wymazanie elementÃ³w z pamiÄ™ci: erase()
* podmiana caÅ‚ego kontenera: swap()
* zliczenie elementÃ³w pasujÄ…cych do danego klucza: count (dla set to 0 albo 1, dla multiset od 0 do n)
* odnalezienie elementu o podanym kluczu: find()

___

## PrzykÅ‚ad `std::unordered_set<T>` i `std::unordered_multiset<T>`

```C++
std::unordered_set<std::string> set{"Ala", "Ma", "Kota", "A", "Kot", "Ma", "ALE"};
for (const auto el : set) {
    std::cout << el << ' ';
}
std::cout << '\n';
set.insert("Ala");
set.insert("Ala");
set.insert("Ala");
for (const auto el : set) {
    std::cout << el << ' ';
}
std::cout << '\n';
```

## `unordered_map<K, T>` i `unordered_multimap<K, T>`

* Zgadnij cechy,
* Zgadnij implementacjÄ™,
* WyÅ›lij przykÅ‚ad wykorzystujÄ…cy te 2 kontenery

## Zadanie 2

* StwÃ³rz `std::unordered_map<int, std::string>` oraz `std::multiset<int>`
* WypeÅ‚nij je dowolnymi wartoÅ›ciami
* UsuÅ„ jeden z elementÃ³w,
* dodaj dodatkowy element
* UsuÅ„ elementy, wedÅ‚ug wymyÅ›lonego przez Ciebie predykatu.
  
___

## Q&A

___
